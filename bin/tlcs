#!/usr/bin/env bash
# Execute a command and tag the output of the stdout and stderr streams.
self=tlcs

# Define usage function
usage() {
    printf 'USAGE: %s [-h] [-c] [-o STDOUT_PREFIX] [-e STDERR_PREFIX] [--] COMMAND [ARG1...]\n' "$self"
}

# Check we have tl(1)
hash tl || exit

# Set the default prefixes and suffixes for stdout/stderr
stdout_prefix='stdout: '
stderr_prefix='stderr: '
stdout_suffix=
stderr_suffix=

# No color by default
declare -i color
color=0

# Parse options out, give help if necessary
while getopts 'hco:e:' opt ; do
    case $opt in

        # -h: Print help
        h)
            usage
            exit
            ;;

        # -c: Add color
        c)
            color=1
            ;;

        # -o: Specify stdout prefix
        o)
            stdout_prefix=$OPTARG
            ;;

        # -e: Specify stderr prefix
        e)
            stderr_prefix=$OPTARG
            ;;

        # Unknown option
        \?)
            usage >&2
            exit 2
            ;;
    esac
done
shift "$((OPTIND-1))"

# If color was requested for the output, figure out what we can do
if ((color)) ; then

    # Color code for resetting
    color_reset=$( {
        tput me || tput sgr0
    } 2>/dev/null )

    # If stdout is a terminal, color-code for green
    if [[ -t 1 ]] ; then
        color_green=$( {
            tput AF 2 || tput setaf 2
        } 2>/dev/null )
        stdout_prefix=${color_green}${stderr_prefix}
        stdout_suffix=$color_reset
    fi

    # If stderr is a terminal, color-code for green
    if [[ -t 2 ]] ; then
        color_red=$( {
            tput AF 1 || tput setaf 1
        } 2>/dev/null )
        stderr_prefix=${color_red}${stderr_prefix}
        stdout_suffix=$color_reset
    fi
fi

# Execute the command, passing stdout and stderr to tl(1) calls as appropriate
"$@" \
    2> >(tl -p "$stderr_prefix" -s "$stderr_suffix") \
    1> >(tl -p "$stdout_prefix" -s "$stdout_suffix")
