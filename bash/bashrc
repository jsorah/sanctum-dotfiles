# Don't do anything if not running interactively.
[[ -z "$PS1" ]] && return

# Use vi as my text editor.
export EDITOR=vi

# Keep plenty of history.
unset HISTFILESIZE
HISTSIZE=1000000

# Ignore duplicate commands and whitespace in history.
HISTCONTROL=ignoreboth

# Keep the times of the commands in history.
HISTTIMEFORMAT='%F %T  '

# Add history entries immediately, not on exit.
PROMPT_COMMAND='history -a'

# Don't check for mail all the time, it's irritating.
unset MAILCHECK

# Autocorrect fudged paths in cd calls.
shopt -s cdspell &>/dev/null

# Update columns and rows if window size changes.
shopt -s checkwinsize &>/dev/null

# Put multi-line commands onto one line of history.
shopt -s cmdhist &>/dev/null

# Autocorrect fudged paths during completion.
shopt -s dirspell &>/dev/null

# Include dotfiles in pattern matching.
shopt -s dotglob &>/dev/null

# Enable advanced pattern matching.
shopt -s extglob &>/dev/null

# Enable double-starring paths.
shopt -s globstar &>/dev/null

# Append rather than overwrite Bash history.
shopt -s histappend &>/dev/null

# Never beep at me.
hash setterm &>/dev/null && setterm -bfreq 0

# Turn off annoying and useless flow control keys.
hash stty &>/dev/null && stty -ixon

# Use completion, if available.
[[ -e /etc/bash_completion ]] && source /etc/bash_completion

# SSH agent setup, if available.
[[ -e "${HOME}/.ssh/agent" ]] && source "${HOME}/.ssh/agent"

# If we're using an xterm, force 256 colors.
case "$TERM" in
    xterm*) TERM=xterm-256color;;
esac

# Figure out how many colors we have now.
hash tput && COLORS=$(tput colors)

# Reset options for ls and grep.
LS_OPTS=
GREP_OPTS=

# If we have a color terminal, we'll use color for ls and grep.
if [[ $COLORS -ge 8 ]]; then
    hash dircolors &>/dev/null && eval "$(dircolors -b)"
    if ls --help | grep -- --color &>/dev/null; then
        LS_OPTS="${LS_OPTS} --color=auto"
    fi
    if grep --help | grep -- --color &>/dev/null; then
        GREP_OPTS="${GREP_OPTS} --color=auto"
    fi
fi

# Set up more options for grep; exclude version control files.
if ls --help | grep -- --exclude &>/dev/null; then
    for PATTERN in .git .gitignore .gitmodules; do
        GREP_OPTS="${GREP_OPTS} --exclude=${PATTERN}"
    done
fi
if grep --help | grep -- --exclude-dir &>/dev/null; then
    for PATTERN in .cvs .git .hg .svn; do
        GREP_OPTS="${GREP_OPTS} --exclude-dir=${PATTERN}"
    done
fi

# Function to display branch of a Git repository.
function prompt_git {
    git branch &>/dev/null || return 1
    HEAD="$(git symbolic-ref HEAD 2>/dev/null)"
    BRANCH="${HEAD##*/}"
    [[ -n "$(git status 2>/dev/null | \
        grep -F 'working directory clean')" ]] || STATUS="!"
    echo -n "(git:${BRANCH:-unknown}${STATUS})"
    return 0
}

# Function to display branch of an SVN working copy.
function prompt_svn {
    svn info &>/dev/null || return 1
    URL="$(svn info 2>/dev/null | \
        awk -F': ' '$1 == "URL" {print $2}')"
    ROOT="$(svn info 2>/dev/null | \
        awk -F': ' '$1 == "Repository Root" {print $2}')"
    BRANCH=${URL/$ROOT}
    BRANCH=${BRANCH#/}
    BRANCH=${BRANCH#branches/}
    BRANCH=${BRANCH%%/*}
    [[ -n "$(svn status 2>/dev/null)" ]] && STATUS="!"
    echo -n "(svn:${BRANCH:-unknown}${STATUS})"
    return 0
}

# Function to display branch of a Mercurial repository.
function prompt_hg {
    hg branch &>/dev/null || return 1
    BRANCH="$(hg branch 2>/dev/null)"
    [[ -n "$(hg status 2>/dev/null)" ]] && STATUS="!"
    echo -n "(hg:${BRANCH:-unknown}${STATUS})"
    return 0
}

# Function that calls each of the above in order of how likely I am to be
# using that kind of repository, to save some cycles.
function prompt_vcs {
    prompt_git || prompt_svn || prompt_hg
    return $?
}

# Function to return the number of backgrounded jobs.
function prompt_jobs {
    [[ -n "$(jobs)" ]] && echo -n "{$(jobs | wc -l | sed 's/ //g')}"
    return $?
}

# Uncolored bits of my prompt, we'll color them if appropriate shortly.
PS1='[\u@\h:\w]$(prompt_vcs)$(prompt_jobs)\$'

# Save some color codes based on our colour space.
if [[ $COLORS -ge 256 ]]; then
    COLOR_ROOT='\[\e[38;5;9m\]'
    COLOR_USER='\[\e[38;5;10m\]'
    COLOR_UNDO='\[\e[0m\]'
elif [[ $COLORS -ge 8 ]]; then
    COLOR_ROOT='\[\e[1;31m\]'
    COLOR_USER='\[\e[1;32m\]'
    COLOR_UNDO='\[\e[0m\]'
else
    COLOR_ROOT=
    COLOR_USER=
    COLOR_UNDO=
fi

# Change prompt color depending on whether I'm root or not.
if [[ $EUID -eq 0 ]]; then
    PS1=${COLOR_ROOT}${PS1}${COLOR_UNDO}
else
    PS1=${COLOR_USER}${PS1}${COLOR_UNDO}
fi

# Add space separator to end of prompt.
PS1="${PS1} "

# Set window titles in various terminals.
case "$TERM" in
    screen*) PS1='\[\ek\h\e\\\]'${PS1};;
    xterm*)  PS1='\[\e]0;\h\a\]'${PS1};;
esac

# If we're a screen terminal within a 256 color outer, force a 256 color
# screen terminal too. This deals with a tmux race condition bug.
case "$CONTAINING_TERM" in
    *256color) 
        TERM=screen-256color
        unset CONTAINING_TERM
        ;;
esac

# Alias ls and grep with the options we've collected.
alias ls="ls ${LS_OPTS}"
alias grep="grep ${GREP_OPTS}"

# Protect innocent MySQL databases from my stupidity.
alias mysql='mysql --safe-updates'

# I always do this, and I hate slow train.
alias sl='ls'

